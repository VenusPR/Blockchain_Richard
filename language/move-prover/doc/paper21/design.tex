\Section{Move Prover Design}

\begin{Figure}
  \centering
  \includegraphics[trim=0 250 0 0, width=\textwidth]{arch.png}
  \caption{Move Prover Architecture}
  \label{fig:Arch}
\end{Figure}

The architecture of \MVP is illustrated in Fig.~\ref{fig:Arch}. Move code
(containing specifications) is given as input to the Move tool chain, which
produces two artifacts: the abstract syntax tree (AST) of the specifications,
and the generated bytecode.  The \emph{Move Model} merges both bytecode and
specifications, as well as other metdata from the original code, into a unique
object model which is input to the remaining tool chain.

The next phase is the actual \emph{Prover Compiler}, which is implemented as a
pipeline of bytecode transformations. Only an excerpt of the most important
transformations is shown (Reference Elimination, Specification Injection, and
Monomorphization). These transformations will be conceptually described in more
detail in subsequent sections. While they happen in reality on an extended
version of the bytecode, we will illustrate them on a higher level of
abstraction, as Move source level transformations.

The transformed bytecode is next compiled into the Boogie intermediate
verification language \cite{BOOGIE}. Boogie supports an imperative programming
model which is well suited for the encoding of the transformed Move code. Boogie
in turn can translate to multiple SMT solver backends, namely Z3 \cite{Z3} and
CVC5 \cite{CVC}; the default choice for the Move prover is currently Z3.

When the SMT solver produces a |sat| or |unknown| result (of the negation of the
verification condition Boogie generates), it produces a model witness. The Move
Prover attempts to translate this model back into a diagnostic which
a user can associate with the original Move code (as has been illustrated in
Sec.~\ref{sec:RunningProver}.) For example, execution traces leading to the
verification failure are shown, with assignments to variables used in this
trace, extracted from the model. Also the Move Model will be consulted to
retrieve the original source information and display it with the diagnosis.

Subsequently, we will focus on the major bytecode transformations.

\SubSection{Reference Elimination}
\label{sec:RefElim}

The Move language supports references to data stored in global memory and on the
stack. Those references can point to interior parts of the data. The reference
system is based on \emph{borrow semantics} \cite{BORROW_SEM} as it is also found
in the Rust programming language.  One can create (immutable) references |&x|
and mutable references |&mut x|, and derive new references by field selection
(|&mut x.f| and |&x.f|). The borrow semantics of Move provides the following
guarantees (ensured by the borrow checker~\cite{BORROW_CHECKER}):

\begin{itemize}
\item For any given location in global memory or on the stack, there can be
  either exactly one mutable reference, or $n$ immutable references. Hereby,
  it does not matter to what interior part of the data is referred to.
\item Dangling references to locations on the stack cannot exist; that is, the
  lifetime of references to data on the stack is restricted to the lifetime of the
  stack location.
\end{itemize}

\noindent These properties enable us to \emph{effectively eliminate} references from the Move
program, reducing the verification complexity significantly, as we do not need to
reason about sharing. It comes as no surprise that the same discipline of borrowing
which makes Move (and Rust) programs safer by design also makes verification simpler.

\Paragraph{Immutable References}

Since during the existance of an immutable reference no mutation on the
referenced data can occur, we can simply replace references by the referred
value.

An example of the applied transformation is shown below. We remove the reference
type constructor and all reference-taking operations from the code:

\begin{Move}
  fun select_f(s: &S): &T { &s.f } @\transform@ fun select_f(s: S): T { s.f }
\end{Move}


\noindent Notice that at Move execution time, immutable references serve
performance objectives (avoid copies); however, the symbolic reasoning engines
we use have a different representation of values, in which structure sharing is
common and copying is cheap.

\Paragraph{Mutable References}
\label{sec:RefElimMut}

Each mutation of a location |l| starts with an initial borrow for the whole data
stored in this location (in Move, |borrow_global_mut<T>(addr)| for global
memory, and |&mut x| for a local on the stack). Let's call the reference
resulting from such a borrow |r|. As long as this reference is alive, Move code
can either update its value (|*r = v|), or replace it with a sub-reference~%
(|r' = &mut r.f|). The mutation ends when |r| (or the derived |r'|) go out of
scope.  Because of the guarantees of the borrow semantics, during the mutation
of the data in |l| no other reference can exist into data in |l|.

The fact that |&mut| has exclusive access to the whole value in a location
allows to reduce mutable references to a \emph{read-update-write} cycle. One can
create a copy of the data in |l| and single-thread it to a sequence of
mutation steps which are represented as purely functional data updates.  Once
the last reference for the data in |l| goes out of scope, the updated value is
written back to |l|. This effectively turns an imperative program with references
into an imperative program which only has state updates on global memory or
variables on the stack, a class of programs which is known to have a significantly
simpler semantics. We illustrate the basics of this approach by an example:

\begin{Move}
  fun increment(x: &mut u64) { *x = *x + 1 }
  fun increment_field(s: &mut S) { increment(&mut s.f) }
  fun caller(): S { let s = S{f:0}; update(&mut s); s }
  @\transform@
  fun increment(x: u64): u64 { x + 1 }
  fun increment_field(s: S): S { s[f = increment(s.f)] }
  fun caller(): S { let s = S{f:0}; s = update(s); s }
\end{Move}

While the setup in this example covers a majority of the use cases in every day
Move code, there are more complex ones to consider, namely that the value of a
reference depends on runtime decisions. This is discussed in App.~\ref{sec:RefElimApx}.


\SubSection{Global Invariant Injection}
\label{sec:GlobalInvariants}

%% Dave comment: We discussed requiring update invariants to be transitive, but I don't think that's
%% a great idea after thinking about it more.  Too long to write here


% wrwg: Need to discuss that the commented model below is really what we want/have. It basically
% means that all invariants are always suspensable until transaction level, which is not what we
% are doing today (and their are reasons we don't want to).
%

\emph{Inductive} invariants are properties declared in Move modules that must
(by default) hold for the global memory at all times. Those invariants typically
quantify over addresses, as in~%
|invariant forall a: address: P(global<S>(a))|. See Fig.~\ref{fig:AccountSpec})
for examples. Based on Move's borrow semantics, inductive invariants don't need
to hold while memory is mutated; this is reflected by the reference elimination
described in Sec.~\ref{sec:RefElim}, and based on that the state of mutation is
not visible to anybody until it is written back to global memory.

\emph{Update} invariants are properties which relate two states.  Typically they
are enforced after an update of global memory, and are able to use the |old|
function to access the state before the update.

Verification of both kinds of global invariants can be \emph{suspended}. That
means, instead of being verified at the time a memory update happens, they are
verified at the call site of the function which updates memory. This is a
feature necessary to describe invariants over dependent parts of the global
memory which cannot be atomically updated.  Functions with external callers
(public or script functions) cannot suspend invariant verification, ensuring
that integrity of verification is preserved.


\Paragraph{Proof Methodology}

Inductive invariants are proved by induction over the evolution of the global
memory. The base case is that the invariant must hold in the empty state that
preceeds the genesis transaction.  For the induction step, we can assume that
the invariant holds at each verified function entry point for which it is not
suspended, and now must prove that it holds after program points which are
either direct updates of global memory, or calls to functions which suspend
invariants.

For update invariants, no soundness issue exist, as they just relate two
memories.  The pre-state is some memory captured before an update happens, and
the post state the current state. When an update invariant is suspended, it
should be designed to be transitive, such that its evaluation is not dependent
from the time of pre-state capture (e.g.~%
|invariant update [suspendable] version() >= old(version())| satisifies this
property).

%% Dave comment: I just noticed the next issue after writing the above paragraph.
%% If we only want to instrument instructions that change the types in invariant,
%% we need to make sure the invariant is valid when there are no changes.}
%% wrwg: only for suspended invariants, and then only if the update actually does
%% not happen in every path. However, the worst can happen is that if fails
%% verification, so seems no issue.
% We assume that an instruction that doesn't modify any of the types
% mentioned in an update invariant also does alter the validity of the invariant.
% Hence, an update invariant, regarded as a binary relation, must be reflexive.
% This property is not currently enforced by the prover.


% wrwg: This is discussed already
% Note that the induction proof
% allows the assumption of \textit{all} invariants at the beginning of each
% verified function to prove that an invariant holds after the function.  In
% practice, a subset of the available invariants are actually assumed on entry to
% a function. Some are not visible to the prover because they are specified
% outside of the cluster being verified, and others are excluded heuristically to
% reduce computational cost.


%% wrwg: we never tried this so don't know whether it is practical
% In some situations (such as blockchains), we would like
% users to be able to write transactions ``on-the-fly'' and submit
% them to the system, which does not allow time to run \MVP
% on individual transactions. The coarsest granularity we can
% practically achieve is to verify that each public and script function preserves
% inductive invariants.

\Paragraph{Modular Verification}

We wish to support open systems to which untrusted modules can be added to
without invalidating invariants that have already been proved. For each
invariant, there is a defined subset of Move modules (called a
\textit{cluster}). If the invariant is proved for the modules in the cluster, it
is guaranteed to hold in all other modules -- even those that were not yet
defined when the invariant was proved.  The cluster must contain every function
that can invalidate the invariant, and, in case of invariant suspension, all
callers of such a function.  Moreover, it must contain any function which calls
a friend function in a module for which the invariant is suspended. Importantly,
functions outside the cluster can never invalidate an invariant, so those
functions trivially preserve the invariant, so it is only necessary to verify
functions defined in the cluster.

\MVP verifies a given set of modules at a time (typically one).  The modules
being verified are called the \textit{target modules}, and the global invariants
to be verified are called \textit{target invariants}, which are all invariants
defined in the target modules. The cluster is then the smallest set as specified
above such that all target modules are contained.

\Paragraph{Basic Translation}

\begin{Figure}
  \caption{Basic Global Invariant Injection}
  \label{fig:GlobalInvariants}
  \centering
\begin{MoveBox}
  fun f(a: address) {
    let r = borrow_global_mut<S>(a);
    r.value = r.value + 1
  }
  invariant [I1] forall a: address: global<S>(a).value > 0;
  invariant [I2] update forall a: address:
      global<S>(a).value > old(global<S>(a).value);
  @\transform@
  fun f(a: address) {
    spec assume I1;
    Mvp::snapshot_state(I2_BEFORE);
    r = <increment mutation>;
    spec assert I1;
    spec assert I2[old = I2_BEFORE];
  }
\end{MoveBox}
\end{Figure}


%% Dave comment: Do we have standard terminology for the state
%%  variables upon which an invariant depends and that a function can
%%  access or modify? We should explain the concepts and terminology
%%  earlier and use them consistently throughout.
%%  wrwg: yes we do: "global memory", "memory update", "memory type"
%%    its defined in the move.tex but perhaps not consistently used

%%  wrwg: this is all already described below. Perhaps we should improve it
%%    instead of double writing
% The injection of assumes and asserts of global invariants into functions
% requires knowing whether a function reads or modifies memory that is mentioned
% in the invariant.  Without generic type parameters, this is a relatively simple
% analysis. First, the prover collects the set of memory types mentioned in the
% invariant.  For choosing the invariants to assume on entry to a function, \MVP
% collects all the types that are read or modified by the function or indirectly
% by functions that it calls, and intersects this set with the set of types in the
% invariant.  For choosing the invariants to assert, \MVP collects types that are
% modified by the function or by an individual instruction or function call and
% intersects that set with the set of types in the invariant.

We first look at injection of global invariants in the absence of memory and
functions with type parameters. Fig.~\ref{fig:GlobalInvariants} contains an
example for the supported invariant types and their injection into code. The
first invariant, |I1|, is an inductive invariant. It is assumed on function
entry, and asserted after the state update. The second, |I2|, is an update
invariant, which relates pre and post states. For this a state snapshot is
stored under some label |I2_BEFORE|, which is then used in an assertion.

Global invariant injection is optimized by knowledge of the prover, obtained by
static analysis, about accessed and modified memory.  Let |accessed(f)| be the
memory accessed by a function, and |modified(f)| the memory be modified. Let
|accessed(I)| by an invariant (including transitively by all functions it
calls).

\begin{itemize}
\item Inject |assume I| at entry to |f| \emph{if} |accessed(f)| has overlap with
  |accessed(I)|.
\item At every point in |f| where a memory location |M| is updated, or where a
  return from a function |f'| happens s.t. |M in modifies(f')| and for
  which |I| is suspended, inject |assert I| after the point \emph{if}~%
  |M in accessed(I)|. Also, if |I| is an update invariant, before the update or
  call inject a memory snapshot save.
\end{itemize}

\Paragraph{Genericity}

\begin{Figure}
  \caption{Global Invariant Injection and Genericity}
  \label{fig:Genericity}
  \centering
\begin{MoveBox}
  invariant [I1] global<S<u64>>(0).value > 1;
  invariant<T> [I2] global<S<T>>(0).value > 0;
  fun f(a: address) { borrow_global_mut<S<u8>>(0).value = 2 }
  fun g<R>(a: address) { borrow_global_mut<S<R>>(0).value = 3 }
  @\transform@
  fun f(a: address) {
    spec assume I2[T = u8];
    <<mutate>>
    spec assert I2[T = u8];
  }
  fun g<R>(a: address) {
    spec assume I1;
    spec assume I2[T = R];
    <<mutate>>
    spec assert I1;
    spec assert I2[T = R];
  }
\end{MoveBox}
\end{Figure}

Generic type parameters make the problem of determining whether a function can
modify an invariant more difficult.  For soundness, a property must hold for
every possible instantiation of type parameters.  So, rather than checking
whether some of the types mentioned in the invariant are equal to some of the
types accessed or modified by a function \MVP needs to discover whether there is
any possible instantiation of type parameters that might allow the instantiated
function to invalidate an instantiated invariant.  In other words, it needs to
know whether the each type in the invariant can be unified with a type accessed
or modified by the function.  Consider the example in
Fig.~\ref{fig:Genericity}. Invariant |I1| holds for a specific type
instantiation |S<u64>|, whereas |I2| is generic over all type instantiations for
|S<T>|.

The non-generic function |f| which works on the instantiation |S<u8>| will have
to inject the \emph{specialized} instance |I2[T = u8]|. The invariant |I1|,
however, does not apply for this function, because there is no overlap with
|S<u64>|.  In contrast, in the generic function |g| we have to inject both
invariants. Because this function works on arbitrary instances, it is also
relevant for the specific case of |S<u64>|.

In the general case, we are looking at a unification problem of the following
kind. Given the accessed memory of a function |f<R>| and an invariant |I<T>|, we
compute the pairwise unification of memory types. Those types are parameterized
over |R| resp. |T|, and successful unification will result in a substitution for
both. On successful unification, we include the invariant with |T| specialized
according to the substitution.

Notice that there are implications related to monomorphization coming from the
injection of global invariants; those are discussed in Sec.~\ref{sec:Mono}.


\SubSection{Monomorphization}
\label{sec:Mono}

Monomorphization is the process of removing all generic types from a Move
program by \emph{specializing the program for all relevant type instantiations}.
Like with genericity in most modern program languages, this is possible in Move
because the number of instantiations is statically known for a given program
fragment.

\Paragraph{Basic Monomorphization}

\begin{Figure}
\caption{Basic Monomorphization}
\label{fig:Mono}
\centering
\begin{MoveBox}
  struct S<T> { .. }
  fun f<T>(x: T) { g<S<T>>(S(x)) }
  fun g<S:key>(s: S) { move_to<S>(.., s) }
  @\transform@
  struct T{}
  struct S_T{ .. }
  fun f_T(x: T) { g_S_T(S_T(x)) }
  fun g_S_T(s: S_T) { move_to<S_T>(.., s) }
\end{MoveBox}
\end{Figure}

To verify a generic function, monomorphization skolemizes the type parameter
into a given type. It then, for all functions which are inlined, inserts their
code specializing it for the given type instantiation, including specialization
of all used types. Fig.~\ref{fig:Mono} sketches this approach.

The underlying conjecture is that if we verify |f_T|, we have also
verified it for all possible instantiations. However, this statement is
only correct for code which does not depend on runtime type information.

\Paragraph{Type Dependent Code}

The type of genericity Move provides does not allow for full type erasure as
often found in programming languages. That is because types are used to
\emph{index} global memory (e.g. |global<S<T>>(addr)| where |T| is a generic
type). Consider the following Move function:

\begin{Move}
  fun f<T>(..) { move_to<S<T>>(s, ..); move_to<S<u64>>(s, ..) }
\end{Move}

\noindent Depending on how |T| is instantiated, this function behaves
differently.  Specifically, if |T| is instantiated with |u64| the function will
always abort at the second |move_to|, since the target location is already
occupied.

The important property enabling monomorphization in the presence of type
dependent code is that one can identify the situation by looking at the memory
accessed by code and injected specifications. From this one can derive
\emph{additional instantiations of the function} which need to be verified. For
the example above, verifying both |f_T| and an instantiation |f_u64| will cover
all relevant cases of the function behavior. Notice that this treatment of type
dependent code is specific to the problem of verification, and cannot directly
be applied to execution.

The algorithm for computing the instances which require verification works as
follows. Let |f<T1,..,Tn>| be a verified target function which has all
specifications injected and inlined function calls expanded.
\begin{itemize}
\item Foreach memory |M in modifies(f)|, if there is a memory~%
  |M' in modifies(f)+accessed(f)| such that |M| and |M'| can unify via |T1,..,Tn|,
  collect an instaniation of the type parameters |Ti| from the resulting
  substitution. This instantiation may not assign values to all type parameters,
  and those unassigned parameters stay as is. For instance, |f<T1, T2>| might
  have a partial instantiation |f<T1, u8>|.
\item Once the set of all those partial instantiations is computed, it is
  extended by unifying the instantiations against each other. If |<t>| and
  |<t'>| are in the set, and they unify under the substitution |s|, then
  |<s(t)>| will also be part of the set.  For example, consider |f<T1, T2>|
  which modifies |M<T1>| and |R<T2>|, as well as accesses |M<u64>| and
  |R<u8>|. From this the instantiations |<u64, T2>| and |<T1, u8>| are computed,
  and the additional instantiation |<u64, u8>| will be added to the set.
\item If after computing and extending instantiations any type parameters
  remain, they are skolemized into a given type as described in the previous
  section.
\end{itemize}

To understand the correctness of this procedure, consider the following arguments:

\begin{itemize}
\item \emph{Direct interaction} Whenever a modified memory |M<t>| can influence
  the interpretation of |M<t'>|, a unifier must exist for the types |t| and |t'|,
  and an instantiation will be verified which covers the overlap of |t| and
  |t'|.
\item \emph{Indirect interaction} If there is an overlap between two types
  which influences whether another overlap is semantically relevant, the
  combination of both overlaps will be verified via the extension step.
\end{itemize}

Notice that even though it is not common in regular Move code to work with both
memory |S<T>| and, say, |S<u64>| in one function, there is a scenario where such
code is implicitly created by injection of global invariants. Consider the
example in Fig.~\ref{fig:Genericity}. The invariant |I1| which works on |S<u64>|
is injected into the function |g<R>| which works on |S<R>|. When monomorphizing
|g|, we need to verify an instance |g_u64| in order to ensure that |I1| holds.



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
